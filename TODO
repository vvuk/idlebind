- use ES6 Proxies to handle 'as'
-- for things that are derived in the IDL, store a C-side static_cast<B>((A*)0) in a static variable, and then read that variable
   on the JS side to know how to adjust an A pointer to become a B
-- use a Proxy and override 'as', so that on the JS side you can just write 'var a = something.GetA();  var b = a as B;' and have it work

- generate JS renames for interface typedefs (e.g. on idl side "typedef Foo Bar;" should result in a "var Bar = Foo;" after class Foo is defined.

smart_ptr strategy:

[SmartPtr]
Foo { }

Foo as non-destructor arg is always 'const smart_ptr<Foo>&'
Foo as return or destructor arg is always 'smart_ptr<Foo>*'

TODO:
  For functions returning Foo(), we need to add some code to make sure
  that the implementation actually returns smart_ptr<Foo> or unique_ptr<Foo>;
  a bare pointer would silently compile